<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdvancedOptionsLabel" xml:space="preserve">
    <value>Options avancées</value>
  </data>
  <data name="AzureActiveDirectoryLabel" xml:space="preserve">
    <value>Azure Active Directory Domain Services</value>
  </data>
  <data name="BatchSizeHelp" xml:space="preserve">
    <value>La taille de lot utilisée pour la récupération, en tant que nombre maximal de lignes</value>
  </data>
  <data name="BatchSizeLabel" xml:space="preserve">
    <value>Taille du lot (lignes)</value>
  </data>
  <data name="ButtonHelp" xml:space="preserve">
    <value>Importer des données depuis Azure Databricks</value>
  </data>
  <data name="ButtonTitle" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="MultiCloudButtonHelp" xml:space="preserve">
    <value>Importer des données depuis Databricks</value>
  </data>
  <data name="MultiCloudButtonTitle" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="CatalogHelp" xml:space="preserve">
    <value>Sélectionnez un catalogue par défaut pour la connexion.</value>
  </data>
  <data name="CatalogLabel" xml:space="preserve">
    <value>Catalogue par défaut</value>
  </data>
  <data name="DatabaseHelp" xml:space="preserve">
    <value>Limitez la connexion à la base de données sélectionnée. Cela peut accélérer la liste des tables, mais cela empêchera le pliage des requêtes pour les requêtes qui touchent plusieurs bases de données différentes.</value>
  </data>
  <data name="DatabaseLabel" xml:space="preserve">
    <value>Base de données</value>
  </data>
  <data name="DataSourceLabel" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="DataSourceName" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="MultiCloudDataSourceLabel" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="MultiCloudDataSourceName" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="EnableAutomaticProxyDiscoveryFlagsHelp" xml:space="preserve">
    <value>Cela permet de détecter automatiquement un proxy à l’échelle du système Windows.</value>
  </data>
  <data name="EnableAutomaticProxyDiscoveryFlagsLabel" xml:space="preserve">
    <value>Détection automatique du proxy</value>
  </data>
  <data name="ErrorAadInvalidDomain" xml:space="preserve">
    <value>AAD n’est pas pris en charge pour le domaine : #{0}.</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorAadInvalidLocation" xml:space="preserve">
    <value>Point de terminaison d’autorisation inattendu reçu du serveur</value>
  </data>
  <data name="ErrorAadRedirectFailed" xml:space="preserve">
    <value>Échec de la récupération du point de terminaison d’autorisation pour l’organisation.</value>
  </data>
  <data name="ErrorAdvancedOptionValue" xml:space="preserve">
    <value>Valeur invalide '#{0}' pour le champ #{1}.</value>
    <comment>#{0}: Field value, #{1}: Field name</comment>
  </data>
  <data name="ErrorExpectedSqlString" xml:space="preserve">
    <value>Requête SQL attendue, mais valeur nulle ou vide.</value>
  </data>
  <data name="ErrorInvalidHost" xml:space="preserve">
    <value>L’hôte n’est pas un nom de domaine valide : #{0}</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorMultiCloudOAuthOnAzureNotSupported" xml:space="preserve">
    <value>L’hôte est dans Azure. Pour les points de terminaison Azure, utilisez la source de données `Azure Databricks` : #{0}</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorInvalidHttpPath" xml:space="preserve">
    <value>Chemin HTTP invalide : #{0}.</value>
    <comment>#{0}: HTTP Path</comment>
  </data>
  <data name="ErrorMissingClientLibrary" xml:space="preserve">
    <value>Le pilote ODBC Databricks n’est pas installé sur l’hôte. Veuillez installer le pilote approprié.</value>
  </data>
  <data name="ErrorOdbcAccessDenied" xml:space="preserve">
    <value>La connexion ODBC a échoué avec les informations d’identification fournies. Réessayez avec des informations d’identification différentes ou un mécanisme d’authentification différent.</value>
  </data>
  <data name="ErrorOdbcCouldNotConnect" xml:space="preserve">
    <value>N’a pas pu se connecter au serveur. Veuillez vérifier votre configuration ODBC. </value>
  </data>
  <data name="AutomaticProxyDiscoveryFlagDisabledLabel" xml:space="preserve">
    <value>Désactivé (par défaut)</value>
  </data>
  <data name="AutomaticProxyDiscoveryFlagEnabledLabel" xml:space="preserve">
    <value>Activé</value>
  </data>
  <data name="HttpPathHelp" xml:space="preserve">
    <value>Le chemin HTTP du cluster.</value>
  </data>
  <data name="HttpPathLabel" xml:space="preserve">
    <value>Chemin d’accès HTTP</value>
  </data>
  <data name="PersonalAccessTokenLabel" xml:space="preserve">
    <value>Jeton d’accès personnel</value>
  </data>
  <data name="OIDCLabel" xml:space="preserve">
    <value>OAuth (OIDC)</value>
  </data>
  <data name="QueryDataSourceDescription" xml:space="preserve">
    <value>Définir une source de données Databricks pour exécuter des requêtes SQL</value>
  </data>
  <data name="QueryDataSourceInstanceDescription" xml:space="preserve">
    <value>Exécutez une requête SQL sur Databricks et récupérez les résultats</value>
  </data>
  <data name="QueryDataSourceInstanceName" xml:space="preserve">
    <value>Requête SQL Databricks</value>
  </data>
  <data name="QueryDataSourceName" xml:space="preserve">
    <value>Source de requête SQL Databricks</value>
  </data>
  <data name="ServerHostNameHelp" xml:space="preserve">
    <value>Nom d’hôte du serveur Databricks.</value>
  </data>
  <data name="ServerHostNameLabel" xml:space="preserve">
    <value>Le nom d’hôte du serveur</value>
  </data>
  <data name="SqlQueryHelp" xml:space="preserve">
    <value>Entrez une requête SQL à exécuter sur Databricks</value>
  </data>
  <data name="SqlQueryLabel" xml:space="preserve">
    <value>Requête SQL</value>
  </data>
  <data name="UsernamePasswordLabel" xml:space="preserve">
    <value>Nom d’utilisateur / Mot de passe</value>
  </data>
</root>