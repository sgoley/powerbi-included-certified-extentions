<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdvancedOptionsLabel" xml:space="preserve">
    <value>Opcje zaawansowane</value>
  </data>
  <data name="AzureActiveDirectoryLabel" xml:space="preserve">
    <value>Azure Active Directory</value>
  </data>
  <data name="BatchSizeHelp" xml:space="preserve">
    <value>Rozmiar partii używany do pobierania jako maksymalna liczba wierszy</value>
  </data>
  <data name="BatchSizeLabel" xml:space="preserve">
    <value>Rozmiar partii (wiersze)</value>
  </data>
  <data name="ButtonHelp" xml:space="preserve">
    <value>Importuj dane z platformy Azure Databricks.</value>
  </data>
  <data name="ButtonTitle" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="MultiCloudButtonHelp" xml:space="preserve">
    <value>Importuj dane z platformy Databricks.</value>
  </data>
  <data name="MultiCloudButtonTitle" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="CatalogHelp" xml:space="preserve">
    <value>Wybierz katalog domyślny dla połączenia.</value>
  </data>
  <data name="CatalogLabel" xml:space="preserve">
    <value>Katalog domyślny</value>
  </data>
  <data name="DatabaseHelp" xml:space="preserve">
    <value>Ogranicz połączenie z wybraną bazą danych. Może to przyspieszyć wyświetlanie tabel, jednak uniemożliwi składanie kwerend w przypadku kwerend, które trafią do wielu różnych baz danych.</value>
  </data>
  <data name="DatabaseLabel" xml:space="preserve">
    <value>Baza danych</value>
  </data>
  <data name="DataSourceLabel" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="DataSourceName" xml:space="preserve">
    <value>Azure Databricks</value>
  </data>
  <data name="MultiCloudDataSourceLabel" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="MultiCloudDataSourceName" xml:space="preserve">
    <value>Databricks</value>
  </data>
  <data name="EnableAutomaticProxyDiscoveryFlagsHelp" xml:space="preserve">
    <value>Umożliwia to automatyczne odnajdywanie serwerów proxy w całym automatycznym systemie Windows.</value>
  </data>
  <data name="EnableAutomaticProxyDiscoveryFlagsLabel" xml:space="preserve">
    <value>Automatyczne odnajdywanie serwerów proxy</value>
  </data>
  <data name="ErrorAadInvalidDomain" xml:space="preserve">
    <value>Usługa AAD nie jest obsługiwana dla domeny: #{0}.</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorAadInvalidLocation" xml:space="preserve">
    <value>Odebrano nieoczekiwany punkt końcowy autoryzacji z serwera</value>
  </data>
  <data name="ErrorAadRedirectFailed" xml:space="preserve">
    <value>Nie można pobrać punktu końcowego autoryzacji dla organizacji.</value>
  </data>
  <data name="ErrorAdvancedOptionValue" xml:space="preserve">
    <value>Nieprawidłowa wartość „#{0}” dla pola #{1}.</value>
    <comment>#{0}: Field value, #{1}: Field name</comment>
  </data>
  <data name="ErrorExpectedSqlString" xml:space="preserve">
    <value>Oczekiwano kwerendy SQL, ale otrzymano wartość null lub wartość pustą.</value>
  </data>
  <data name="ErrorInvalidHost" xml:space="preserve">
    <value>Host nie jest prawidłową nazwą domeny: #{0}</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorMultiCloudOAuthOnAzureNotSupported" xml:space="preserve">
    <value>Host znajduje się na platformie Azure. W przypadku punktów końcowych platformy Azure użyj źródła danych „Azure Databricks”: #{0}</value>
    <comment>#{0}: Domain</comment>
  </data>
  <data name="ErrorInvalidHttpPath" xml:space="preserve">
    <value>Nieprawidłowa ścieżka HTTP: #{0}.</value>
    <comment>#{0}: HTTP Path</comment>
  </data>
  <data name="ErrorMissingClientLibrary" xml:space="preserve">
    <value>Sterownik ODBC platformy Databricks nie jest zainstalowany na hoście. Zainstaluj odpowiedni sterownik.</value>
  </data>
  <data name="ErrorOdbcAccessDenied" xml:space="preserve">
    <value>Połączenie ODBC nie powiodło się z podanymi poświadczeniami. Spróbuj ponownie, używając innych poświadczeń lub innego mechanizmu uwierzytelniania.</value>
  </data>
  <data name="ErrorOdbcCouldNotConnect" xml:space="preserve">
    <value>Nie można nawiązać połączenia z serwerem. Sprawdź dokładnie konfigurację ODBC. </value>
  </data>
  <data name="AutomaticProxyDiscoveryFlagDisabledLabel" xml:space="preserve">
    <value>Wyłączone (domyślnie)</value>
  </data>
  <data name="AutomaticProxyDiscoveryFlagEnabledLabel" xml:space="preserve">
    <value>Włączone</value>
  </data>
  <data name="HttpPathHelp" xml:space="preserve">
    <value>Ścieżka HTTP klastra.</value>
  </data>
  <data name="HttpPathLabel" xml:space="preserve">
    <value>Ścieżka HTTP</value>
  </data>
  <data name="PersonalAccessTokenLabel" xml:space="preserve">
    <value>Osobisty token dostępu</value>
  </data>
  <data name="OIDCLabel" xml:space="preserve">
    <value>OAuth (OIDC)</value>
  </data>
  <data name="QueryDataSourceDescription" xml:space="preserve">
    <value>Zdefiniuj źródło danych platformy Databricks do uruchamiania kwerend SQL</value>
  </data>
  <data name="QueryDataSourceInstanceDescription" xml:space="preserve">
    <value>Uruchom kwerendę SQL na platformie Databricks i pobierz wyniki</value>
  </data>
  <data name="QueryDataSourceInstanceName" xml:space="preserve">
    <value>Kwerenda SQL na platformie Databricks</value>
  </data>
  <data name="QueryDataSourceName" xml:space="preserve">
    <value>Narzędzie SQL Query Source na platformie Databricks</value>
  </data>
  <data name="ServerHostNameHelp" xml:space="preserve">
    <value>Nazwa hosta serwera platformy Databricks.</value>
  </data>
  <data name="ServerHostNameLabel" xml:space="preserve">
    <value>Nazwa hosta serwera</value>
  </data>
  <data name="SqlQueryHelp" xml:space="preserve">
    <value>Wprowadź kwerendę SQL do uruchomienia na platformie Databricks</value>
  </data>
  <data name="SqlQueryLabel" xml:space="preserve">
    <value>Kwerenda SQL</value>
  </data>
  <data name="UsernamePasswordLabel" xml:space="preserve">
    <value>Nazwa użytkownika / hasło</value>
  </data>
</root>